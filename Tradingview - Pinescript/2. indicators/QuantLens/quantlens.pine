// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© TheTradingSpiderMan

//@version=6
indicator('âšœï¸ ðð®ðšð§ð­ð‹ðžð§ð¬ âšœï¸', overlay = true, max_lines_count = 500, max_boxes_count = 500, max_labels_count = 500)

// Import Libraries
import TheTradingSpiderMan/MovingAverages/1 as MA
import TheTradingSpiderMan/ColorsLibrary/2 as CLR

src = close

// Color Theme Selection
colorTheme = input.string("DEFAULT", "Color Theme", options=["DEFAULT", "MONO", "VAPOR", "NEON", "OCEAN", "SUNSET", "FOREST", "CANDY", "FIRE", "ICE"], group = "Colors")

// MA Type Options
var maTypeOptions = array.from("SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "DEMA", "TEMA", "KAMA", "T3", "ALMA", "FRAMA", "VIDYA", "JMA", "MCGINLEY", "ZLEMA", "LSMA", "TMA", "SUPERSMOOTHER", "LAGUERRE")

// Signal MAs (Small & Big)
var signalMaGroup = 'Signal MAs'
maS_type = input.string("EMA", "1. Signal MA", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "DEMA", "TEMA", "KAMA", "T3", "ALMA", "FRAMA", "VIDYA", "JMA", "MCGINLEY", "ZLEMA", "LSMA", "TMA", "SUPERSMOOTHER", "LAGUERRE"], inline = 'maS', group = signalMaGroup)
maS_value = input.int(12, minval = 1, title = '', inline = 'maS', group = signalMaGroup)
maS_show = input.bool(true, title = '', inline = 'maS', group = signalMaGroup)
maS = MA.selector(close, maS_value, maS_type)

maB_type = input.string("EMA", "2. Signal MA", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "DEMA", "TEMA", "KAMA", "T3", "ALMA", "FRAMA", "VIDYA", "JMA", "MCGINLEY", "ZLEMA", "LSMA", "TMA", "SUPERSMOOTHER", "LAGUERRE"], inline = 'maB', group = signalMaGroup)
maB_value = input.int(21, minval = 1, title = '', inline = 'maB', group = signalMaGroup)
maB_show = input.bool(true, title = '', inline = 'maB', group = signalMaGroup)
maB = MA.selector(close, maB_value, maB_type)

// Background Trend Inputs
enableBgColor = input.bool(false, 'Background Trend Color', group = signalMaGroup)
bgTrendBullishCol = CLR.bullColor(colorTheme, 90)
bgTrendBearishCol = CLR.bearColor(colorTheme, 90)

// Additional MAs (50, 100, 200)
var additionalMaGroup = 'Additional MAs'
ma50_type = input.string("EMA", "1. Extra MA", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "DEMA", "TEMA", "KAMA", "T3", "ALMA", "FRAMA", "VIDYA", "JMA", "MCGINLEY", "ZLEMA", "LSMA", "TMA", "SUPERSMOOTHER", "LAGUERRE"], inline = 'ma50', group = additionalMaGroup)
ma50_value = input.int(50, minval = 1, title = '', inline = 'ma50', group = additionalMaGroup)
ma50_show = input.bool(true, title = '', inline = 'ma50', group = additionalMaGroup)
ma50 = MA.selector(close, ma50_value, ma50_type)

ma100_type = input.string("EMA", "2. Extra MA", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "DEMA", "TEMA", "KAMA", "T3", "ALMA", "FRAMA", "VIDYA", "JMA", "MCGINLEY", "ZLEMA", "LSMA", "TMA", "SUPERSMOOTHER", "LAGUERRE"], inline = 'ma100', group = additionalMaGroup)
ma100_value = input.int(100, minval = 1, title = '', inline = 'ma100', group = additionalMaGroup)
ma100_show = input.bool(true, title = '', inline = 'ma100', group = additionalMaGroup)
ma100 = MA.selector(close, ma100_value, ma100_type)

ma200_type = input.string("EMA", "3. Extra MA", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "DEMA", "TEMA", "KAMA", "T3", "ALMA", "FRAMA", "VIDYA", "JMA", "MCGINLEY", "ZLEMA", "LSMA", "TMA", "SUPERSMOOTHER", "LAGUERRE"], inline = 'ma200', group = additionalMaGroup)
ma200_value = input.int(200, minval = 1, title = '', inline = 'ma200', group = additionalMaGroup)
ma200_show = input.bool(true, title = '', inline = 'ma200', group = additionalMaGroup)
ma200 = MA.selector(close, ma200_value, ma200_type)

// Get colors from library based on selected theme
EMA_UpTrend_color = CLR.bullColor(colorTheme)
EMA_DownTrend_color = CLR.bearColor(colorTheme)

// Liquidity Levels Inputs
var liqGroupName = 'Liquidity Levels Settings'
enableLiqLevels = input.bool(false, title='Enable Liquidity Levels', group=liqGroupName)
liqResistanceColor = CLR.bearColor(colorTheme)
liqSupportColor = CLR.bullColor(colorTheme)
liqLineStyle = input.string("Dotted", options=["Dashed", "Dotted", "Solid"], title="Liquidity Lines Style", group=liqGroupName)
liqLineWidth = input.int(1, "Liquidity Lines Width", minval=1, maxval=5, step=1, group=liqGroupName)
liqExtendType = input.string('Touch', title='Extend Lines Until', options=['Touch', 'Close'], group=liqGroupName, tooltip='Extend the lines until price touches them or a candle closes beyond them.')
liqPivotSensitivity = input.int(20, "Pivot Sensitivity", minval=1, maxval=50, group=liqGroupName)
liqMaxLines = input.int(10, "Max Liquidity Lines", minval=10, maxval=100, group=liqGroupName)

// Volume Profile Inputs
var vpGroupName = 'Volume Profile Settings'
enableVolumeProfile = input.bool(false, title='Enable Volume Profile', group=vpGroupName)
vpDays = input.int(7, title='Lookback Days', minval=1, maxval=30, group=vpGroupName, tooltip='Number of days of data to use for volume profile calculation')
vpRows = input.int(50, title='Number of Rows', minval=10, maxval=200, group=vpGroupName, tooltip='Number of price levels to divide the range into')
vpBaseColor = input.color(#1976d2, 'Band Color', group=vpGroupName, tooltip='Base color for volume bands')
vpPocColor = input.color(color.new(#ffffff, 0), 'POC Line Color', group=vpGroupName)
vpShowPoc = input.bool(true, title='Show POC Line', group=vpGroupName, tooltip='Point of Control - price level with highest volume')
vpShowPocLabel = input.bool(true, title='Show POC Label', group=vpGroupName, tooltip='Show volume label at POC')
vpMinOpacity = input.int(85, title='Min Opacity %', minval=50, maxval=98, group=vpGroupName, tooltip='Opacity for lowest volume bands (higher = more transparent)')
vpMaxOpacity = input.int(30, title='Max Opacity %', minval=0, maxval=50, group=vpGroupName, tooltip='Opacity for highest volume bands (lower = more solid)')

// Rules For Up and Down MA trends
MA_UpTrend = maS >= maB
MA_DownTrend = maS < maB

// Plot MAs on chart using library trend colors
plot(maS_show ? maS : na, color = CLR.trendColor(MA_UpTrend, colorTheme), title = 'MA Small', style = plot.style_line, linewidth = 2, linestyle = plot.linestyle_dotted, offset = 0, display = display.pane)
plot(maB_show ? maB : na, color = CLR.trendColor(MA_UpTrend, colorTheme), title = 'MA Big', style = plot.style_line, linewidth = 2, linestyle = plot.linestyle_dotted, offset = 0, display = display.pane)

// Plot Independent MAs with price-based coloring
plot(ma50_show ? ma50 : na, color = CLR.trendColor(close >= ma50, colorTheme), title = 'MA 50', style = plot.style_line, linewidth = 2, offset = 0, display = display.pane)
plot(ma100_show ? ma100 : na, color = CLR.trendColor(close >= ma100, colorTheme), title = 'MA 100', style = plot.style_line, linewidth = 3, offset = 0, display = display.pane)
plot(ma200_show ? ma200 : na, color = CLR.trendColor(close >= ma200, colorTheme), title = 'MA 200', style = plot.style_line, linewidth = 4, offset = 0, display = display.pane)

// Background Trend Logic
backgroundTrendColor = color.white
if MA_UpTrend
    backgroundTrendColor := bgTrendBullishCol
    backgroundTrendColor
else if MA_DownTrend
    backgroundTrendColor := bgTrendBearishCol
    backgroundTrendColor
else
    backgroundTrendColor := backgroundTrendColor[1]
    backgroundTrendColor

bgcolor(enableBgColor ? backgroundTrendColor : na, force_overlay = true)

// Alerts
alertcondition(ta.crossover(maS, maB), title = 'MA Trend Up', message = 'MA Trend Up - {{ticker}} - {{interval}}')
alertcondition(ta.crossunder(maS, maB), title = 'MA Trend Down', message = 'MA Trend Down - {{ticker}} - {{interval}}')

// Watermark
showWatermark = input.bool(true, 'Show Watermark', group = 'Watermark')
title = input.string('ðð®ðšð§ð­ð•ð¢ðžð° | ðð®ðšð§ð­ð‹ðžð§ð¬', 'Title', group = 'Watermark')
subtitle = input.string('ðƒð„ð’ðˆð†ð   |   ðƒð„ð•ð„ð‹ðŽð   |   ðƒð„ðð‹ðŽð˜', 'Subtitle', group = 'Watermark')
showDate = input.bool(true, 'Show Date', group = 'Watermark')
showSymbolInfo = input.bool(true, 'Show Ticker & Timeframe', group = 'Watermark')
c_title = input.color(color.new(color.white, 0), 'Title Color', group = 'Watermark')
c_subtitle = input.color(color.new(color.white, 30), 'Subtitle Color', group = 'Watermark')
c_symInfo = input.color(color.new(color.white, 30), 'Symbol Color', group = 'Watermark')

// Timeframe display formatting (convert minutes >= 60 to hours)
tfMinutes = timeframe.in_seconds(timeframe.period) / 60
tfDisplay = timeframe.isminutes ? (tfMinutes >= 60 ? str.tostring(int(tfMinutes / 60)) + 'h' : str.tostring(int(tfMinutes)) + 'm') : timeframe.period

symInfo = syminfo.ticker + ' | ' + tfDisplay
dateStr = str.tostring(dayofmonth(time_close)) + '/' + str.tostring(month(time_close)) + '/' + str.tostring(year(time_close))

// Text Watermark Table
var table textWatermark = table.new(position.top_center, 1, 2, bgcolor = color.new(color.white, 100), border_width = 0)
if showWatermark
    table.cell(textWatermark, 0, 0, title, 0, 0, c_title, text_halign = text.align_center, text_size = size.large)
    table.cell(textWatermark, 0, 1, subtitle, 0, 0, c_subtitle, text_halign = text.align_center, text_size = size.normal)

// Symbol Info Watermark Table
var table symWatermark = table.new(position.bottom_center, 1, 2, bgcolor = color.new(color.white, 100), border_width = 0)
if showDate
    table.cell(symWatermark, 0, 0, dateStr, 0, 0, c_symInfo, text_halign = text.align_center, text_size = size.normal)
if showSymbolInfo
    table.cell(symWatermark, 0, 1, symInfo, 0, 0, c_symInfo, text_halign = text.align_center, text_size = size.normal)

// ============================================================================
// Sessions
// ============================================================================
// Custom Session
show_sese = input.bool(false, '', inline = 'sese', group = 'Custom Session')
sese_txt = input.string('Custom', '', inline = 'sese', group = 'Custom Session')
sese_ses = input.session('0000-0000', '', inline = 'sese', group = 'Custom Session')
sese_css = input.color(#9c27b0, '', inline = 'sese', group = 'Custom Session')

// Session A
show_sesa = input.bool(false, '', inline = 'sesa', group = 'Session A')
sesa_txt = input.string('New York', '', inline = 'sesa', group = 'Session A')
sesa_ses = input.session('1300-2200', '', inline = 'sesa', group = 'Session A')
sesa_css = input.color(#ff5d00, '', inline = 'sesa', group = 'Session A')

// Session B
show_sesb = input.bool(false, '', inline = 'sesb', group = 'Session B')
sesb_txt = input.string('London', '', inline = 'sesb', group = 'Session B')
sesb_ses = input.session('0700-1600', '', inline = 'sesb', group = 'Session B')
sesb_css = input.color(#2157f3, '', inline = 'sesb', group = 'Session B')

// Session C
show_sesc = input.bool(false, '', inline = 'sesc', group = 'Session C')
sesc_txt = input.string('Tokyo', '', inline = 'sesc', group = 'Session C')
sesc_ses = input.session('0000-0900', '', inline = 'sesc', group = 'Session C')
sesc_css = input.color(#e91e63, '', inline = 'sesc', group = 'Session C')

// Session D
show_sesd = input.bool(false, '', inline = 'sesd', group = 'Session D')
sesd_txt = input.string('Sydney', '', inline = 'sesd', group = 'Session D')
sesd_ses = input.session('2100-0600', '', inline = 'sesd', group = 'Session D')
sesd_css = input.color(#ffeb3b, '', inline = 'sesd', group = 'Session D')

// Sessions Settings
tz_incr = input.int(0, 'UTC (+/-)', group = 'Sessions Settings')
use_exchange = input.bool(false, 'Use Exchange Timezone', group = 'Sessions Settings')
bg_transp = input.float(90, 'Range Area Transparency', group = 'Sessions Settings')
show_outline = input.bool(true, 'Range Outline', group = 'Sessions Settings')
show_txt = input.bool(true, 'Range Label', group = 'Sessions Settings')

// Daily Divider
show_day_div = input.bool(true, 'Show Daily Divider', group = 'Daily Divider')

// Session Functions
get_range(session, session_name, session_css) =>
    var t = 0
    var max = high
    var min = low
    var box bx = na
    var label lbl = na

    if session > session[1]
        t := time
        max := high
        min := low
        bx := box.new(bar_index, max, bar_index, min, bgcolor = color.new(session_css, bg_transp), border_color = show_outline ? session_css : na, border_style = line.style_dotted)
        if show_txt
            lbl := label.new(t, max, session_name, xloc = xloc.bar_time, textcolor = session_css, style = label.style_label_down, color = color.new(color.white, 100), size = size.tiny)

    if session != 0 and session == session[1]
        max := math.max(high, max)
        min := math.min(low, min)
        box.set_top(bx, max)
        box.set_rightbottom(bx, bar_index, min)
        if show_txt
            label.set_xy(lbl, int(math.avg(t, time)), max)

// Timezone
var tz = use_exchange ? syminfo.timezone : str.format('UTC{0}{1}', tz_incr >= 0 ? '+' : '-', math.abs(tz_incr))

// Session Detection
tf = timeframe.period
is_sesa = math.sign(nz(time(tf, sesa_ses, tz)))
is_sesb = math.sign(nz(time(tf, sesb_ses, tz)))
is_sesc = math.sign(nz(time(tf, sesc_ses, tz)))
is_sesd = math.sign(nz(time(tf, sesd_ses, tz)))
is_sese = math.sign(nz(time(tf, sese_ses, tz)))

// Draw Session Ranges
if show_sesa
    get_range(is_sesa, sesa_txt, sesa_css)
if show_sesb
    get_range(is_sesb, sesb_txt, sesb_css)
if show_sesc
    get_range(is_sesc, sesc_txt, sesc_css)
if show_sesd
    get_range(is_sesd, sesd_txt, sesd_css)
if show_sese
    get_range(is_sese, sese_txt, sese_css)

// ============================================================================
// Daily Divider
// ============================================================================
day = dayofweek

if day != day[1] and show_day_div
    line.new(bar_index, close + syminfo.mintick, bar_index, close - syminfo.mintick, color = color.gray, extend = extend.both, style = line.style_dashed)

plotshape(day != day[1] and day == 1 and show_day_div, 'Sunday', shape.labeldown, location.top, na, text = 'Sunday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)
plotshape(day != day[1] and day == 2 and show_day_div, 'Monday', shape.labeldown, location.top, na, text = 'Monday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)
plotshape(day != day[1] and day == 3 and show_day_div, 'Tuesday', shape.labeldown, location.top, na, text = 'Tuesday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)
plotshape(day != day[1] and day == 4 and show_day_div, 'Wednesday', shape.labeldown, location.top, na, text = 'Wednesday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)
plotshape(day != day[1] and day == 5 and show_day_div, 'Thursday', shape.labeldown, location.top, na, text = 'Thursday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)
plotshape(day != day[1] and day == 6 and show_day_div, 'Friday', shape.labeldown, location.top, na, text = 'Friday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)
plotshape(day != day[1] and day == 7 and show_day_div, 'Saturday', shape.labeldown, location.top, na, text = 'Saturday', textcolor = color.gray, size = size.tiny, display = display.all - display.status_line, editable = false)

// ============================================================================
// Liquidity Levels (Support/Resistance)
// ============================================================================
liqLineStyleResolved = switch liqLineStyle
    "Solid" => line.style_solid
    "Dotted" => line.style_dotted
    "Dashed" => line.style_dashed

// Identify pivot highs and pivot lows
liqPivotHigh = ta.pivothigh(high, liqPivotSensitivity, liqPivotSensitivity)
liqPivotLow = ta.pivotlow(low, liqPivotSensitivity, liqPivotSensitivity)

// Initialize arrays to store the lines
var line[] liqResistanceLines = array.new_line(0)
var line[] liqSupportLines = array.new_line(0)
var int[] liqResistanceTouchBars = array.new_int(0)
var int[] liqSupportTouchBars = array.new_int(0)
liqLookback = 500

// Function to manage line limits (removing the oldest line if limit is exceeded)
f_manage_liq_line_limit(array<line> linesArray, array<int> touchBarsArray) =>
    if array.size(linesArray) > liqMaxLines
        line.delete(array.shift(linesArray))
        array.shift(touchBarsArray)

// Draw new resistance liquidity line if a new pivot high is detected
if (enableLiqLevels and not na(liqPivotHigh) and bar_index[liqPivotSensitivity] >= bar_index - liqLookback)
    pivotHighPrice = high[liqPivotSensitivity]
    pivotHighBar = bar_index[liqPivotSensitivity]
    resistanceLine = line.new(pivotHighBar, pivotHighPrice, bar_index + 1, pivotHighPrice, style=liqLineStyleResolved, width=liqLineWidth, color=liqResistanceColor, extend=extend.right)
    array.push(liqResistanceLines, resistanceLine)
    array.push(liqResistanceTouchBars, na)
    f_manage_liq_line_limit(liqResistanceLines, liqResistanceTouchBars)

// Draw new support liquidity line if a new pivot low is detected
if (enableLiqLevels and not na(liqPivotLow) and bar_index[liqPivotSensitivity] >= bar_index - liqLookback)
    pivotLowPrice = low[liqPivotSensitivity]
    pivotLowBar = bar_index[liqPivotSensitivity]
    supportLine = line.new(pivotLowBar, pivotLowPrice, bar_index + 1, pivotLowPrice, style=liqLineStyleResolved, width=liqLineWidth, color=liqSupportColor, extend=extend.right)
    array.push(liqSupportLines, supportLine)
    array.push(liqSupportTouchBars, na)
    f_manage_liq_line_limit(liqSupportLines, liqSupportTouchBars)

// Loop through resistance lines and stop extension if price touches them
if array.size(liqResistanceLines) > 0
    resLineStop = liqExtendType == 'Close' ? close : high
    for i = 0 to array.size(liqResistanceLines) - 1
        line currentResistanceLine = array.get(liqResistanceLines, i)
        resistancePrice = line.get_y1(currentResistanceLine)
        touchBar = array.get(liqResistanceTouchBars, i)

        if na(touchBar)
            line.set_x2(currentResistanceLine, bar_index)
            line.set_extend(currentResistanceLine, extend.none)

        if na(touchBar) and resLineStop >= resistancePrice
            line.set_x2(currentResistanceLine, bar_index)
            line.set_extend(currentResistanceLine, extend.none)
            array.set(liqResistanceTouchBars, i, bar_index)

// Loop through support lines and stop extension if price touches them
if array.size(liqSupportLines) > 0
    supLineStop = liqExtendType == 'Close' ? close : low
    for i = 0 to array.size(liqSupportLines) - 1
        line currentSupportLine = array.get(liqSupportLines, i)
        supportPrice = line.get_y1(currentSupportLine)
        touchBar = array.get(liqSupportTouchBars, i)

        if na(touchBar)
            line.set_x2(currentSupportLine, bar_index)
            line.set_extend(currentSupportLine, extend.none)

        if na(touchBar) and supLineStop <= supportPrice
            line.set_x2(currentSupportLine, bar_index)
            line.set_extend(currentSupportLine, extend.none)
            array.set(liqSupportTouchBars, i, bar_index)

// ============================================================================
// Volume Profile (Full-Width Horizontal Bands)
// ============================================================================
// Calculate bars for lookback period (approximate based on timeframe)
vpBarsPerDay = switch
    timeframe.isseconds => 86400 / timeframe.in_seconds(timeframe.period)
    timeframe.isminutes => 1440 / timeframe.in_seconds(timeframe.period) * 60
    timeframe.isdaily => 1
    timeframe.isweekly => 1 / 5
    timeframe.ismonthly => 1 / 21
    => 390  // Default for intraday (6.5 hours * 60 minutes)

vpLookback = math.min(int(vpDays * vpBarsPerDay), bar_index)

// Arrays for volume profile boxes
var box[] vpBoxes = array.new_box(0)
var line vpPocLine = na
var label vpPocLabel = na

// Only calculate and draw on last bar for performance
if barstate.islast and enableVolumeProfile
    // Clear previous boxes
    if array.size(vpBoxes) > 0
        for i = 0 to array.size(vpBoxes) - 1
            box.delete(array.get(vpBoxes, i))
        array.clear(vpBoxes)

    // Delete previous POC line and label
    if not na(vpPocLine)
        line.delete(vpPocLine)
    if not na(vpPocLabel)
        label.delete(vpPocLabel)

    // Find price range over lookback period
    float vpHighest = high
    float vpLowest = low
    for i = 1 to vpLookback
        if i <= bar_index
            vpHighest := math.max(vpHighest, high[i])
            vpLowest := math.min(vpLowest, low[i])

    // Calculate row height
    float vpRange = vpHighest - vpLowest
    float vpRowHeight = vpRange / vpRows

    // Arrays to store volume per row
    var float[] vpVolume = array.new_float(vpRows, 0.0)

    // Reset volume array
    for i = 0 to vpRows - 1
        array.set(vpVolume, i, 0.0)

    // Accumulate volume into rows
    for i = 0 to vpLookback
        if i <= bar_index and vpRowHeight > 0
            float barMidPrice = (high[i] + low[i]) / 2
            int rowIndex = int((barMidPrice - vpLowest) / vpRowHeight)
            rowIndex := math.max(0, math.min(vpRows - 1, rowIndex))
            float barVol = nz(volume[i])
            array.set(vpVolume, rowIndex, array.get(vpVolume, rowIndex) + barVol)

    // Find max volume and POC for scaling
    float maxVol = 0.0
    int pocIndex = 0
    float pocVol = 0.0
    for i = 0 to vpRows - 1
        float rowVol = array.get(vpVolume, i)
        maxVol := math.max(maxVol, rowVol)
        if rowVol > pocVol
            pocVol := rowVol
            pocIndex := i

    // Full chart width for bands
    int vpLeftEdge = bar_index - vpLookback
    int vpRightEdge = bar_index + 50

    // Draw full-width horizontal bands with opacity based on volume
    for i = 0 to vpRows - 1
        float rowBottom = vpLowest + (i * vpRowHeight)
        float rowTop = rowBottom + vpRowHeight
        float rowVol = array.get(vpVolume, i)

        if rowVol > 0 and maxVol > 0
            // Calculate opacity based on volume (more volume = more solid)
            float volRatio = rowVol / maxVol
            int bandOpacity = int(vpMinOpacity - (volRatio * (vpMinOpacity - vpMaxOpacity)))
            color bandColor = color.new(vpBaseColor, bandOpacity)

            // Draw full-width horizontal band
            box bandBox = box.new(vpLeftEdge, rowTop, vpRightEdge, rowBottom, bgcolor=bandColor, border_color=na, border_width=0)
            array.push(vpBoxes, bandBox)

    // Draw POC line (bright white line at highest volume)
    if vpShowPoc
        float pocPrice = vpLowest + (pocIndex * vpRowHeight) + (vpRowHeight / 2)
        vpPocLine := line.new(vpLeftEdge, pocPrice, vpRightEdge, pocPrice, color=vpPocColor, width=3, style=line.style_solid)

        // Draw POC label with volume
        if vpShowPocLabel
            string volText = pocVol >= 1000000 ? str.tostring(pocVol / 1000000, '#.###') + 'M' : pocVol >= 1000 ? str.tostring(pocVol / 1000, '#.###') + 'K' : str.tostring(pocVol, '#.#')
            vpPocLabel := label.new(vpRightEdge, pocPrice, 'POC ' + volText, style=label.style_label_left, color=color.new(#424242, 20), textcolor=color.white, size=size.small)
