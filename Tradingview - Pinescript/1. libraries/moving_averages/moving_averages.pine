// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © TheTradingSpiderMan

//@version=6
//@description A comprehensive library containing all types of Moving Average calculations for PineScript v6.
library("MovingAverages", overlay = true)

//-----------------------------------------------------------------------------
// SIMPLE MOVING AVERAGE (SMA)
//-----------------------------------------------------------------------------
//@function Calculates Simple Moving Average - arithmetic mean of prices over a period
//@param src Source series
//@param len Period length
//@returns SMA value
export sma(float src, int len) =>
    ta.sma(src, len)

//-----------------------------------------------------------------------------
// EXPONENTIAL MOVING AVERAGE (EMA)
//-----------------------------------------------------------------------------
//@function Calculates Exponential Moving Average - weighted average giving more importance to recent prices
//@param src Source series
//@param len Period length
//@returns EMA value
export ema(float src, int len) =>
    ta.ema(src, len)

//-----------------------------------------------------------------------------
// WEIGHTED MOVING AVERAGE (WMA)
//-----------------------------------------------------------------------------
//@function Calculates Weighted Moving Average - linear weighted average
//@param src Source series
//@param len Period length
//@returns WMA value
export wma(float src, int len) =>
    ta.wma(src, len)

//-----------------------------------------------------------------------------
// VOLUME WEIGHTED MOVING AVERAGE (VWMA)
//-----------------------------------------------------------------------------
//@function Calculates Volume Weighted Moving Average
//@param src Source series
//@param len Period length
//@returns VWMA value
export vwma(float src, int len) =>
    ta.vwma(src, len)

//-----------------------------------------------------------------------------
// HULL MOVING AVERAGE (HMA)
//-----------------------------------------------------------------------------
//@function Calculates Hull Moving Average - reduces lag while maintaining smoothness
//@param src Source series
//@param len Period length
//@returns HMA value
export hma(float src, int len) =>
    ta.hma(src, len)

//-----------------------------------------------------------------------------
// RELATIVE MOVING AVERAGE (RMA) / SMMA / MMA
//-----------------------------------------------------------------------------
//@function Calculates Relative Moving Average (also known as Smoothed MA or Modified MA)
//@param src Source series
//@param len Period length
//@returns RMA value
export rma(float src, int len) =>
    ta.rma(src, len)

//-----------------------------------------------------------------------------
// SYMMETRICALLY WEIGHTED MOVING AVERAGE (SWMA)
//-----------------------------------------------------------------------------
//@function Calculates Symmetrically Weighted Moving Average (4-period fixed)
//@param src Source series
//@returns SWMA value
export swma(float src) =>
    ta.swma(src)

//-----------------------------------------------------------------------------
// ARNAUD LEGOUX MOVING AVERAGE (ALMA)
//-----------------------------------------------------------------------------
//@function Calculates Arnaud Legoux Moving Average - Gaussian distribution weighted
//@param src Source series
//@param len Period length
//@param offset Offset (0-1, controls the center of the curve)
//@param sigma Sigma (controls the shape of the curve)
//@returns ALMA value
export alma(float src, int len, float offset = 0.85, float sigma = 6.0) =>
    ta.alma(src, len, offset, sigma)

//-----------------------------------------------------------------------------
// DOUBLE EXPONENTIAL MOVING AVERAGE (DEMA)
//-----------------------------------------------------------------------------
//@function Calculates Double Exponential Moving Average - reduces lag
//@param src Source series
//@param len Period length
//@returns DEMA value
export dema(float src, int len) =>
    float e1 = ta.ema(src, len)
    float e2 = ta.ema(e1, len)
    2 * e1 - e2

//-----------------------------------------------------------------------------
// TRIPLE EXPONENTIAL MOVING AVERAGE (TEMA)
//-----------------------------------------------------------------------------
//@function Calculates Triple Exponential Moving Average - further reduces lag
//@param src Source series
//@param len Period length
//@returns TEMA value
export tema(float src, int len) =>
    float e1 = ta.ema(src, len)
    float e2 = ta.ema(e1, len)
    float e3 = ta.ema(e2, len)
    3 * (e1 - e2) + e3

//-----------------------------------------------------------------------------
// TRIANGULAR MOVING AVERAGE (TMA / TRIMA)
//-----------------------------------------------------------------------------
//@function Calculates Triangular Moving Average - double-smoothed SMA
//@param src Source series
//@param len Period length
//@returns TMA value
export tma(float src, int len) =>
    ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)

//-----------------------------------------------------------------------------
// ZERO LAG EXPONENTIAL MOVING AVERAGE (ZLEMA)
//-----------------------------------------------------------------------------
//@function Calculates Zero Lag EMA - attempts to eliminate lag
//@param src Source series
//@param len Period length
//@returns ZLEMA value
export zlema(float src, int len) =>
    int lag = math.floor((len - 1) / 2)
    float srcAdj = src + (src - nz(src[lag]))
    ta.ema(srcAdj, len)

//-----------------------------------------------------------------------------
// KAUFMAN ADAPTIVE MOVING AVERAGE (KAMA)
//-----------------------------------------------------------------------------
//@function Calculates Kaufman Adaptive Moving Average - adjusts to market volatility
//@param src Source series
//@param len Period length
//@param fastLen Fast EMA period (default 2)
//@param slowLen Slow EMA period (default 30)
//@returns KAMA value
export kama(float src, int len, int fastLen = 2, int slowLen = 30) =>
    float change = math.abs(src - nz(src[len]))
    float volatility = math.sum(math.abs(src - nz(src[1])), len)
    float er = volatility != 0 ? change / volatility : 0
    float fastSC = 2.0 / (fastLen + 1)
    float slowSC = 2.0 / (slowLen + 1)
    float sc = math.pow(er * (fastSC - slowSC) + slowSC, 2)
    var float kamaVal = na
    kamaVal := nz(kamaVal[1]) + sc * (src - nz(kamaVal[1]))
    kamaVal

//-----------------------------------------------------------------------------
// FRACTAL ADAPTIVE MOVING AVERAGE (FRAMA)
//-----------------------------------------------------------------------------
//@function Calculates Fractal Adaptive Moving Average - uses fractal dimension
//@param src Source series
//@param len Period length
//@returns FRAMA value
export frama(float src, int len) =>
    int halfLen = math.floor(len / 2)
    float n1 = (ta.highest(high, halfLen) - ta.lowest(low, halfLen)) / halfLen
    float n2 = (ta.highest(high[halfLen], halfLen) - ta.lowest(low[halfLen], halfLen)) / halfLen
    float n3 = (ta.highest(high, len) - ta.lowest(low, len)) / len
    float d = n1 > 0 and n2 > 0 and n3 > 0 ? (math.log(n1 + n2) - math.log(n3)) / math.log(2) : 0
    float alpha = math.exp(-4.6 * (d - 1))
    alpha := math.max(0.01, math.min(1, alpha))
    var float framaVal = na
    framaVal := nz(framaVal[1]) + alpha * (src - nz(framaVal[1]))
    framaVal

//-----------------------------------------------------------------------------
// VARIABLE INDEX DYNAMIC AVERAGE (VIDYA)
//-----------------------------------------------------------------------------
//@function Calculates Variable Index Dynamic Average - CMO-based adaptive MA
//@param src Source series
//@param len Period length
//@returns VIDYA value
export vidya(float src, int len) =>
    float change = ta.change(src)
    float sumUp = math.sum(change > 0 ? change : 0, len)
    float sumDown = math.sum(change < 0 ? math.abs(change) : 0, len)
    float cmo = (sumUp - sumDown) / (sumUp + sumDown)
    float k = 2.0 / (len + 1)
    var float vidyaVal = na
    vidyaVal := nz(vidyaVal[1]) + k * math.abs(cmo) * (src - nz(vidyaVal[1]))
    vidyaVal

//-----------------------------------------------------------------------------
// JURIK MOVING AVERAGE (JMA) - Simplified Version
//-----------------------------------------------------------------------------
//@function Calculates Jurik-style Moving Average - smooth and responsive
//@param src Source series
//@param len Period length
//@param phase Phase adjustment (-100 to 100)
//@returns JMA value
export jma(float src, int len, float phase = 0) =>
    float phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5
    float beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
    float alpha = math.pow(beta, phaseRatio)
    var float e0 = na
    var float e1 = na
    var float e2 = na
    e0 := (1 - alpha) * src + alpha * nz(e0[1])
    e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
    e2 := (e0 + phaseRatio * e1 - nz(e2[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
    e2

//-----------------------------------------------------------------------------
// T3 MOVING AVERAGE
//-----------------------------------------------------------------------------
//@function Calculates T3 Moving Average - multiple EMA smoothing with volume factor
//@param src Source series
//@param len Period length
//@param vFactor Volume factor (default 0.7)
//@returns T3 value
export t3(float src, int len, float vFactor = 0.7) =>
    float c1 = -vFactor * vFactor * vFactor
    float c2 = 3 * vFactor * vFactor + 3 * vFactor * vFactor * vFactor
    float c3 = -6 * vFactor * vFactor - 3 * vFactor - 3 * vFactor * vFactor * vFactor
    float c4 = 1 + 3 * vFactor + vFactor * vFactor * vFactor + 3 * vFactor * vFactor
    float e1 = ta.ema(src, len)
    float e2 = ta.ema(e1, len)
    float e3 = ta.ema(e2, len)
    float e4 = ta.ema(e3, len)
    float e5 = ta.ema(e4, len)
    float e6 = ta.ema(e5, len)
    c1 * e6 + c2 * e5 + c3 * e4 + c4 * e3

//-----------------------------------------------------------------------------
// MCGINLEY DYNAMIC
//-----------------------------------------------------------------------------
//@function Calculates McGinley Dynamic - self-adjusting MA that tracks price
//@param src Source series
//@param len Period length
//@returns McGinley Dynamic value
export mcginley(float src, int len) =>
    var float md = na
    md := na(md[1]) ? src : md[1] + (src - md[1]) / (len * math.pow(src / md[1], 4))
    md

//-----------------------------------------------------------------------------
// LEAST SQUARES MOVING AVERAGE (LSMA) / LINEAR REGRESSION
//-----------------------------------------------------------------------------
//@function Calculates Least Squares Moving Average (Linear Regression)
//@param src Source series
//@param len Period length
//@returns LSMA value
export lsma(float src, int len) =>
    ta.linreg(src, len, 0)

//-----------------------------------------------------------------------------
// SINE WEIGHTED MOVING AVERAGE (SINWMA)
//-----------------------------------------------------------------------------
//@function Calculates Sine Weighted Moving Average
//@param src Source series
//@param len Period length
//@returns SINWMA value
export sinwma(float src, int len) =>
    float sum = 0.0
    float weightSum = 0.0
    for i = 0 to len - 1
        float weight = math.sin((i + 1) * math.pi / (len + 1))
        sum := sum + nz(src[i]) * weight
        weightSum := weightSum + weight
    sum / weightSum

//-----------------------------------------------------------------------------
// VARIABLE MOVING AVERAGE (VMA)
//-----------------------------------------------------------------------------
//@function Calculates Variable Moving Average - volatility-adjusted
//@param src Source series
//@param len Period length
//@returns VMA value
export vma(float src, int len) =>
    float k = 1.0 / len
    float pdm = math.max(src - nz(src[1]), 0)
    float mdm = math.max(nz(src[1]) - src, 0)
    float pdmS = math.sum(pdm, len)
    float mdmS = math.sum(mdm, len)
    float s = pdmS + mdmS
    float pdi = pdmS / s
    float mdi = mdmS / s
    float vr = math.abs(pdi - mdi) / (pdi + mdi)
    var float vmaVal = na
    vmaVal := nz(vmaVal[1]) + k * vr * (src - nz(vmaVal[1]))
    vmaVal


//-----------------------------------------------------------------------------
// EHLERS SUPER SMOOTHER
//-----------------------------------------------------------------------------
//@function Calculates Ehlers Super Smoother filter - minimal lag smoothing
//@param src Source series
//@param len Period length
//@returns Super Smoother value
export superSmoother(float src, int len) =>
    float a = math.exp(-1.414 * math.pi / len)
    float b = 2 * a * math.cos(1.414 * math.pi / len)
    float c2 = b
    float c3 = -a * a
    float c1 = 1 - c2 - c3
    var float ss = na
    ss := c1 * (src + nz(src[1])) / 2 + c2 * nz(ss[1]) + c3 * nz(ss[2])
    ss

//-----------------------------------------------------------------------------
// EXPONENTIAL HULL MOVING AVERAGE (EHMA)
//-----------------------------------------------------------------------------
//@function Calculates Exponential Hull Moving Average - EMA-based HMA
//@param src Source series
//@param len Period length
//@returns EHMA value
export ehma(float src, int len) =>
    ta.ema(2 * ta.ema(src, math.floor(len / 2)) - ta.ema(src, len), math.floor(math.sqrt(len)))

//-----------------------------------------------------------------------------
// WEIGHTED CLOSING PRICE
//-----------------------------------------------------------------------------
//@function Calculates Weighted Close - (High + Low + 2*Close) / 4
//@returns Weighted Close value
export wcp() =>
    (high + low + 2 * close) / 4

//-----------------------------------------------------------------------------
// TYPICAL PRICE
//-----------------------------------------------------------------------------
//@function Calculates Typical Price - (High + Low + Close) / 3
//@returns Typical Price value
export typicalPrice() =>
    hlc3

//-----------------------------------------------------------------------------
// MEDIAN PRICE
//-----------------------------------------------------------------------------
//@function Calculates Median Price - (High + Low) / 2
//@returns Median Price value
export medianPrice() =>
    hl2

//-----------------------------------------------------------------------------
// TRIPLE EMA OSCILLATOR (TRIX) SMOOTHED
//-----------------------------------------------------------------------------
//@function Calculates TRIX-smoothed price (triple EMA base)
//@param src Source series
//@param len Period length
//@returns TRIX smoothed value
export trixSmooth(float src, int len) =>
    ta.ema(ta.ema(ta.ema(src, len), len), len)

//-----------------------------------------------------------------------------
// WELLES WILDER SMOOTHING (Same as RMA but explicit)
//-----------------------------------------------------------------------------
//@function Calculates Welles Wilder Smoothing - used in RSI, ATR
//@param src Source series
//@param len Period length
//@returns Wilder Smoothing value
export wilderSmooth(float src, int len) =>
    var float ws = na
    ws := na(ws[1]) ? src : (ws[1] * (len - 1) + src) / len
    ws

//-----------------------------------------------------------------------------
// RECURSIVE MOVING TRENDLINE (RMT)
//-----------------------------------------------------------------------------
//@function Calculates Recursive Moving Trendline
//@param src Source series
//@param len Period length
//@returns RMT value
export rmt(float src, int len) =>
    float alpha = 2.0 / (len + 1)
    var float trend = na
    trend := na(trend[1]) ? src : trend[1] + alpha * (src - trend[1])
    trend

//-----------------------------------------------------------------------------
// QUADRATIC REGRESSION MA (QRMA)
//-----------------------------------------------------------------------------
//@function Calculates Quadratic Regression Moving Average
//@param src Source series
//@param len Period length
//@returns QRMA value
export qrma(float src, int len) =>
    float sumX = 0.0, float sumY = 0.0, float sumX2 = 0.0, float sumX3 = 0.0, float sumX4 = 0.0
    float sumXY = 0.0, float sumX2Y = 0.0
    for i = 0 to len - 1
        float x = i
        float y = nz(src[len - 1 - i])
        sumX := sumX + x
        sumY := sumY + y
        sumX2 := sumX2 + x * x
        sumX3 := sumX3 + x * x * x
        sumX4 := sumX4 + x * x * x * x
        sumXY := sumXY + x * y
        sumX2Y := sumX2Y + x * x * y
    float n = len
    float det = n * sumX2 * sumX4 + sumX * sumX3 * sumX2 + sumX2 * sumX * sumX3 - sumX2 * sumX2 * sumX2 - sumX * sumX * sumX4 - n * sumX3 * sumX3
    float a0 = (sumY * sumX2 * sumX4 + sumX * sumX3 * sumX2Y + sumX2 * sumXY * sumX3 - sumX2 * sumX2 * sumX2Y - sumX * sumXY * sumX4 - sumY * sumX3 * sumX3) / det
    a0

//-----------------------------------------------------------------------------
// ROLLING VMA (RVMA)
//-----------------------------------------------------------------------------
//@function Calculates Rolling VMA
//@param src Source series
//@param len Period length
//@returns RVMA value
export rvma(float src, int len) =>
    float v = ta.stdev(src, len)
    float d = ta.sma(v, len)
    float ratio = d != 0 ? v / d : 1
    var float rvmaVal = na
    rvmaVal := nz(rvmaVal[1]) + (2.0 / (len + 1)) * ratio * (src - nz(rvmaVal[1]))
    rvmaVal

//-----------------------------------------------------------------------------
// NATURAL MOVING AVERAGE (NMA)
//-----------------------------------------------------------------------------
//@function Calculates Natural Moving Average
//@param src Source series
//@param len Period length
//@returns NMA value
export nma(float src, int len) =>
    float lambda = len / 2.0
    float sum = 0.0
    float weightSum = 0.0
    for i = 0 to len - 1
        float weight = math.exp(-i / lambda)
        sum := sum + nz(src[i]) * weight
        weightSum := weightSum + weight
    sum / weightSum

//-----------------------------------------------------------------------------
// ENDPOINT MOVING AVERAGE (EPMA)
//-----------------------------------------------------------------------------
//@function Calculates Endpoint Moving Average - linear regression endpoint
//@param src Source series
//@param len Period length
//@returns EPMA value
export epma(float src, int len) =>
    ta.linreg(src, len, 0)

//-----------------------------------------------------------------------------
// GAUSSIAN WEIGHTED MOVING AVERAGE (GWMA)
//-----------------------------------------------------------------------------
//@function Calculates Gaussian Weighted Moving Average
//@param src Source series
//@param len Period length
//@returns GWMA value
export gwma(float src, int len) =>
    float sigma = len / 3.0
    float sum = 0.0
    float weightSum = 0.0
    for i = 0 to len - 1
        float weight = math.exp(-0.5 * math.pow((i - len / 2) / sigma, 2))
        sum := sum + nz(src[i]) * weight
        weightSum := weightSum + weight
    sum / weightSum

//-----------------------------------------------------------------------------
// REGULARIZED EMA (REMA)
//-----------------------------------------------------------------------------
//@function Calculates Regularized EMA - smooth version with lambda regularization
//@param src Source series
//@param len Period length
//@param lambda Regularization factor (default 0.5)
//@returns REMA value
export rema(float src, int len, float lambda = 0.5) =>
    float alpha = 2.0 / (len + 1)
    var float remaVal = na
    remaVal := na(remaVal[1]) ? src : (remaVal[1] + alpha * (src - remaVal[1]) + lambda * (2 * remaVal[1] - nz(remaVal[2]))) / (1 + lambda)
    remaVal

//-----------------------------------------------------------------------------
// MODULAR FILTER (MF)
//-----------------------------------------------------------------------------
//@function Calculates Modular Filter
//@param src Source series
//@param len Period length
//@param beta Sensitivity factor (default 0.8)
//@returns MF value
export modularFilter(float src, int len, float beta = 0.8) =>
    float alpha = 2.0 / (len + 1)
    var float b = na, var float c = na
    b := na(b[1]) ? src : alpha * src + (1 - alpha) * nz(b[1])
    c := na(c[1]) ? src : (src - b) * (1 - beta) + beta * nz(c[1])
    b + c

//-----------------------------------------------------------------------------
// LAGUERRE FILTER
//-----------------------------------------------------------------------------
//@function Calculates Laguerre Filter - very smooth minimal lag filter
//@param src Source series
//@param gamma Damping factor (0-1, default 0.8)
//@returns Laguerre Filter value
export laguerreFilter(float src, float gamma = 0.8) =>
    var float l0 = na, var float l1 = na, var float l2 = na, var float l3 = na
    l0 := (1 - gamma) * src + gamma * nz(l0[1])
    l1 := -gamma * l0 + nz(l0[1]) + gamma * nz(l1[1])
    l2 := -gamma * l1 + nz(l1[1]) + gamma * nz(l2[1])
    l3 := -gamma * l2 + nz(l2[1]) + gamma * nz(l3[1])
    (l0 + 2 * l1 + 2 * l2 + l3) / 6

//-----------------------------------------------------------------------------
// SMOOTHED MOVING AVERAGE (SMMA) - Explicit alias for RMA
//-----------------------------------------------------------------------------
//@function Calculates Smoothed Moving Average (same as RMA)
//@param src Source series
//@param len Period length
//@returns SMMA value
export smma(float src, int len) =>
    ta.rma(src, len)

//-----------------------------------------------------------------------------
// CUMULATIVE MOVING AVERAGE (CMA)
//-----------------------------------------------------------------------------
//@function Calculates Cumulative Moving Average - average of all data from start
//@param src Source series
//@returns CMA value
export cma(float src) =>
    ta.cum(src) / bar_index

//-----------------------------------------------------------------------------
// MEDIAN MOVING AVERAGE (MedMA)
//-----------------------------------------------------------------------------
//@function Calculates Median Moving Average - median value over period
//@param src Source series
//@param len Period length
//@returns Median MA value
export medianMA(float src, int len) =>
    ta.median(src, len)

//-----------------------------------------------------------------------------
// GEOMETRIC MOVING AVERAGE (GMA)
//-----------------------------------------------------------------------------
//@function Calculates Geometric Moving Average - geometric mean of prices
//@param src Source series
//@param len Period length
//@returns GMA value
export gma(float src, int len) =>
    float logSum = 0.0
    for i = 0 to len - 1
        logSum := logSum + math.log(math.max(nz(src[i]), 0.0001))
    math.exp(logSum / len)

//-----------------------------------------------------------------------------
// HARMONIC MOVING AVERAGE (HARMA)
//-----------------------------------------------------------------------------
//@function Calculates Harmonic Moving Average - harmonic mean of prices
//@param src Source series
//@param len Period length
//@returns Harmonic MA value
export harmonicMA(float src, int len) =>
    float recipSum = 0.0
    for i = 0 to len - 1
        recipSum := recipSum + 1.0 / math.max(nz(src[i]), 0.0001)
    len / recipSum

//-----------------------------------------------------------------------------
// ELASTIC VOLUME WEIGHTED MA (EVWMA)
//-----------------------------------------------------------------------------
//@function Calculates Elastic Volume Weighted Moving Average
//@param src Source series
//@param len Period length
//@returns EVWMA value
export evwma(float src, int len) =>
    float volumeSum = math.sum(volume, len)
    var float evwmaVal = na
    evwmaVal := na(evwmaVal[1]) ? src : (volumeSum - volume) / volumeSum * nz(evwmaVal[1]) + volume / volumeSum * src
    evwmaVal

//-----------------------------------------------------------------------------
// HOLT-WINTERS MOVING AVERAGE (HWMA)
//-----------------------------------------------------------------------------
//@function Calculates Holt-Winters Moving Average - triple exponential smoothing
//@param src Source series
//@param len Period length
//@returns HWMA value
export hwma(float src, int len) =>
    float alpha = 2.0 / (len + 1)
    float beta = alpha / 2
    float gamma = alpha / 4
    var float level = na, var float trend = na, var float seasonal = na
    level := na(level[1]) ? src : alpha * src + (1 - alpha) * (nz(level[1]) + nz(trend[1]))
    trend := na(trend[1]) ? 0 : beta * (level - nz(level[1])) + (1 - beta) * nz(trend[1])
    seasonal := na(seasonal[1]) ? 0 : gamma * (src - level) + (1 - gamma) * nz(seasonal[1])
    level + trend + seasonal

//-----------------------------------------------------------------------------
// GENERALIZED DEMA (GDEMA)
//-----------------------------------------------------------------------------
//@function Calculates Generalized Double EMA with custom multiplier
//@param src Source series
//@param len Period length
//@param mult Multiplier (default 2 = standard DEMA)
//@returns GDEMA value
export gdema(float src, int len, float mult = 2.0) =>
    float e1 = ta.ema(src, len)
    float e2 = ta.ema(e1, len)
    (1 + mult) * e1 - mult * e2

//-----------------------------------------------------------------------------
// CORAL TREND INDICATOR
//-----------------------------------------------------------------------------
//@function Calculates Coral Trend - modified EMA with smoothing
//@param src Source series
//@param len Period length
//@returns Coral value
export coral(float src, int len) =>
    float di = (len - 1.0) / 2.0 + 1.0
    float c1 = 2.0 / (di + 1.0)
    float c2 = 1.0 - c1
    float c3 = 3.0 * (0.5 * 0.5 + 0.5 * 0.5 * 0.5)
    float c4 = -3.0 * (2.0 * 0.5 * 0.5 + 0.5 + 0.5 * 0.5 * 0.5)
    float c5 = 3.0 * 0.5 + 1.0 + 0.5 * 0.5 * 0.5 + 3.0 * 0.5 * 0.5
    var float i1 = na, var float i2 = na, var float i3 = na, var float i4 = na, var float i5 = na, var float i6 = na
    i1 := c1 * src + c2 * nz(i1[1])
    i2 := c1 * i1 + c2 * nz(i2[1])
    i3 := c1 * i2 + c2 * nz(i3[1])
    i4 := c1 * i3 + c2 * nz(i4[1])
    i5 := c1 * i4 + c2 * nz(i5[1])
    i6 := c1 * i5 + c2 * nz(i6[1])
    -0.5 * 0.5 * 0.5 * i6 + c3 * i5 + c4 * i4 + c5 * i3

//-----------------------------------------------------------------------------
// INTEGRAL OF LINEAR REGRESSION SLOPE (ILRS)
//-----------------------------------------------------------------------------
//@function Calculates Integral of Linear Regression Slope
//@param src Source series
//@param len Period length
//@returns ILRS value
export ilrs(float src, int len) =>
    float slope = ta.linreg(src, len, 0) - ta.linreg(src, len, 1)
    var float ilrsVal = na
    ilrsVal := nz(ilrsVal[1]) + slope
    ilrsVal

//-----------------------------------------------------------------------------
// INSTANTANEOUS TRENDLINE (Ehlers)
//-----------------------------------------------------------------------------
//@function Calculates Ehlers Instantaneous Trendline
//@param src Source series
//@returns Instantaneous Trendline value
export instantTrend(float src) =>
    float alpha = 0.07
    var float it = na
    it := bar_index < 7 ? (src + 2 * nz(src[1]) + nz(src[2])) / 4 : (alpha - 0.25 * alpha * alpha) * src + 0.5 * alpha * alpha * nz(src[1]) - (alpha - 0.75 * alpha * alpha) * nz(src[2]) + 2 * (1 - alpha) * nz(it[1]) - (1 - alpha) * (1 - alpha) * nz(it[2])
    it

//-----------------------------------------------------------------------------
// BUTTERWORTH FILTER (2-Pole)
//-----------------------------------------------------------------------------
//@function Calculates 2-Pole Butterworth Filter
//@param src Source series
//@param len Period length
//@returns Butterworth 2-pole value
export butterworth2(float src, int len) =>
    float a = math.exp(-1.414 * math.pi / len)
    float b = 2 * a * math.cos(1.414 * math.pi / len)
    float c2 = b
    float c3 = -a * a
    float c1 = (1 - c2 - c3) / 4
    var float bw = na
    bw := c1 * (src + 2 * nz(src[1]) + nz(src[2])) + c2 * nz(bw[1]) + c3 * nz(bw[2])
    bw

//-----------------------------------------------------------------------------
// BUTTERWORTH FILTER (3-Pole)
//-----------------------------------------------------------------------------
//@function Calculates 3-Pole Butterworth Filter
//@param src Source series
//@param len Period length
//@returns Butterworth 3-pole value
export butterworth3(float src, int len) =>
    float a = math.exp(-math.pi / len)
    float b = 2 * a * math.cos(1.738 * math.pi / len)
    float c = a * a
    float d2 = b + c
    float d3 = -(c + b * c)
    float d4 = c * c
    float d1 = (1 - d2 - d3 - d4) / 8
    var float bw3 = na
    bw3 := d1 * (src + 3 * nz(src[1]) + 3 * nz(src[2]) + nz(src[3])) + d2 * nz(bw3[1]) + d3 * nz(bw3[2]) + d4 * nz(bw3[3])
    bw3

//-----------------------------------------------------------------------------
// ADAPTIVE LAGUERRE FILTER
//-----------------------------------------------------------------------------
//@function Calculates Adaptive Laguerre Filter - self-adjusting gamma
//@param src Source series
//@param len Period length for adaptation
//@returns Adaptive Laguerre value
export adaptiveLaguerre(float src, int len) =>
    float hh = ta.highest(high, len)
    float ll = ta.lowest(low, len)
    float gamma = hh != ll ? math.abs((src - ll) / (hh - ll) - 0.5) * 2 : 0.5
    var float l0 = na, var float l1 = na, var float l2 = na, var float l3 = na
    l0 := (1 - gamma) * src + gamma * nz(l0[1])
    l1 := -gamma * l0 + nz(l0[1]) + gamma * nz(l1[1])
    l2 := -gamma * l1 + nz(l1[1]) + gamma * nz(l2[1])
    l3 := -gamma * l2 + nz(l2[1]) + gamma * nz(l3[1])
    (l0 + 2 * l1 + 2 * l2 + l3) / 6

//-----------------------------------------------------------------------------
// VOLUME ADJUSTED MA (VAMA)
//-----------------------------------------------------------------------------
//@function Calculates Volume Adjusted Moving Average
//@param src Source series
//@param len Period length
//@returns VAMA value
export vama(float src, int len) =>
    float volRatio = volume / ta.sma(volume, len)
    float adaptLen = math.max(1, math.round(len / volRatio))
    ta.sma(src, int(adaptLen))

//-----------------------------------------------------------------------------
// LEO MOVING AVERAGE
//-----------------------------------------------------------------------------
//@function Calculates Leo Moving Average - WMA-based
//@param src Source series
//@param len Period length
//@returns Leo MA value
export leoMA(float src, int len) =>
    2 * ta.wma(src, len) - ta.sma(src, len)

//-----------------------------------------------------------------------------
// DEVIATION SCALED MOVING AVERAGE (DSMA / EDSMA)
//-----------------------------------------------------------------------------
//@function Calculates Ehlers Deviation Scaled Moving Average
//@param src Source series
//@param len Period length
//@returns EDSMA value
export edsma(float src, int len) =>
    float zeros = src - nz(src[2])
    float avgZeros = ta.sma(zeros, len)
    float rms = math.sqrt(ta.sma(zeros * zeros, len))
    float ratio = rms != 0 ? avgZeros / rms : 0
    float alpha = math.abs(ratio) * 5 / len
    alpha := math.max(0.001, math.min(1, alpha))
    var float dsma = na
    dsma := nz(dsma[1]) + alpha * (src - nz(dsma[1]))
    dsma

//-----------------------------------------------------------------------------
// TRIMMED MOVING AVERAGE (TrMA)
//-----------------------------------------------------------------------------
//@function Calculates Trimmed Moving Average - removes extreme values
//@param src Source series
//@param len Period length
//@param trimPct Percentage to trim from each end (0-0.5, default 0.1)
//@returns Trimmed MA value
export trimmedMA(float src, int len, float trimPct = 0.1) =>
    int trimCount = math.max(1, int(len * trimPct))
    float[] values = array.new_float(len)
    for i = 0 to len - 1
        array.set(values, i, nz(src[i]))
    array.sort(values)
    float sum = 0.0
    int count = 0
    for i = trimCount to len - 1 - trimCount
        sum := sum + array.get(values, i)
        count := count + 1
    count > 0 ? sum / count : ta.sma(src, len)

//-----------------------------------------------------------------------------
// MESA ADAPTIVE MOVING AVERAGE (MAMA)
//-----------------------------------------------------------------------------
//@function Calculates MAMA and FAMA - Ehlers Mesa Adaptive MA
//@param src Source series
//@param fastLimit Fast limit (default 0.5)
//@param slowLimit Slow limit (default 0.05)
//@returns MAMA value
export mama(float src, float fastLimit = 0.5, float slowLimit = 0.05) =>
    var float smooth = na, var float detrender = na, var float period = na
    var float q1 = na, var float i1 = na, var float i2 = na, var float q2 = na
    var float re = na, var float im = na, var float mamaVal = na, var float fama = na
    var float phase = na
    smooth := (4 * src + 3 * nz(src[1]) + 2 * nz(src[2]) + nz(src[3])) / 10
    detrender := (0.0962 * smooth + 0.5769 * nz(smooth[2]) - 0.5769 * nz(smooth[4]) - 0.0962 * nz(smooth[6])) * (0.075 * nz(period[1]) + 0.54)
    q1 := (0.0962 * detrender + 0.5769 * nz(detrender[2]) - 0.5769 * nz(detrender[4]) - 0.0962 * nz(detrender[6])) * (0.075 * nz(period[1]) + 0.54)
    i1 := nz(detrender[3])
    float jI = (0.0962 * i1 + 0.5769 * nz(i1[2]) - 0.5769 * nz(i1[4]) - 0.0962 * nz(i1[6])) * (0.075 * nz(period[1]) + 0.54)
    float jQ = (0.0962 * q1 + 0.5769 * nz(q1[2]) - 0.5769 * nz(q1[4]) - 0.0962 * nz(q1[6])) * (0.075 * nz(period[1]) + 0.54)
    i2 := i1 - jQ
    q2 := q1 + jI
    i2 := 0.2 * i2 + 0.8 * nz(i2[1])
    q2 := 0.2 * q2 + 0.8 * nz(q2[1])
    re := i2 * nz(i2[1]) + q2 * nz(q2[1])
    im := i2 * nz(q2[1]) - q2 * nz(i2[1])
    re := 0.2 * re + 0.8 * nz(re[1])
    im := 0.2 * im + 0.8 * nz(im[1])
    period := im != 0 and re != 0 ? 2 * math.pi / math.atan(im / re) : nz(period[1])
    period := math.min(math.max(period, 6), 50)
    period := 0.2 * period + 0.8 * nz(period[1])
    phase := i1 != 0 ? math.atan(q1 / i1) * 180 / math.pi : nz(phase[1])
    float deltaPhase = math.max(1, nz(phase[1]) - phase)
    float alpha = math.max(slowLimit, math.min(fastLimit, fastLimit / deltaPhase))
    mamaVal := alpha * src + (1 - alpha) * nz(mamaVal[1])
    mamaVal

//-----------------------------------------------------------------------------
// FAMA (Following Adaptive MA)
//-----------------------------------------------------------------------------
//@function Calculates FAMA - Following Adaptive MA (companion to MAMA)
//@param src Source series
//@param fastLimit Fast limit (default 0.5)
//@param slowLimit Slow limit (default 0.05)
//@returns FAMA value
export fama(float src, float fastLimit = 0.5, float slowLimit = 0.05) =>
    float mamaVal = mama(src, fastLimit, slowLimit)
    float alpha = 0.5
    var float famaVal = na
    famaVal := alpha * mamaVal + (1 - alpha) * nz(famaVal[1])
    famaVal

//-----------------------------------------------------------------------------
// TRIPLE WEIGHTED MOVING AVERAGE (TWMA)
//-----------------------------------------------------------------------------
//@function Calculates Triple Weighted Moving Average
//@param src Source series
//@param len Period length
//@returns TWMA value
export twma(float src, int len) =>
    ta.wma(ta.wma(ta.wma(src, len), len), len)

//-----------------------------------------------------------------------------
// SMOOTHED WMA (SWWMA)
//-----------------------------------------------------------------------------
//@function Calculates Smoothed Weighted Moving Average
//@param src Source series
//@param len Period length
//@returns Smoothed WMA value
export swwma(float src, int len) =>
    ta.wma(ta.wma(src, len), len)

//-----------------------------------------------------------------------------
// PERCENTAGE PRICE OSCILLATOR MA (PPOMA)
//-----------------------------------------------------------------------------
//@function Calculates PPO-based Moving Average
//@param src Source series
//@param len Period length
//@returns PPOMA value
export ppoMA(float src, int len) =>
    float shortLen = math.max(1, len / 2)
    float longLen = len
    float shortEma = ta.ema(src, int(shortLen))
    float longEma = ta.ema(src, int(longLen))
    (shortEma + longEma) / 2

//-----------------------------------------------------------------------------
// RUNNING MOVING AVERAGE (RunMA)
//-----------------------------------------------------------------------------
//@function Calculates Running Moving Average
//@param src Source series
//@param len Period length
//@returns Running MA value
export runningMA(float src, int len) =>
    var float runMA = na
    runMA := na(runMA[1]) ? src : runMA[1] + (src - nz(src[len])) / len
    runMA

//-----------------------------------------------------------------------------
// APEX MOVING AVERAGE (AMA variant)
//-----------------------------------------------------------------------------
//@function Calculates Apex Moving Average - fast/slow adaptive
//@param src Source series
//@param len Period length
//@returns Apex MA value
export apexMA(float src, int len) =>
    float fastest = 2.0 / 3.0
    float slowest = 2.0 / (len + 1)
    float direction = math.abs(src - nz(src[len]))
    float volatility = math.sum(math.abs(src - nz(src[1])), len)
    float er = volatility != 0 ? direction / volatility : 0
    float smooth = math.pow(er * (fastest - slowest) + slowest, 2)
    var float apex = na
    apex := nz(apex[1]) + smooth * (src - nz(apex[1]))
    apex

//-----------------------------------------------------------------------------
// FISHER TRANSFORM MA
//-----------------------------------------------------------------------------
//@function Calculates Fisher Transform-based smoothing
//@param src Source series
//@param len Period length
//@returns Fisher smoothed value
export fisherMA(float src, int len) =>
    float hh = ta.highest(src, len)
    float ll = ta.lowest(src, len)
    float value = hh != ll ? 2 * ((src - ll) / (hh - ll) - 0.5) : 0
    value := math.max(-0.999, math.min(0.999, value))
    var float fish = na
    fish := 0.5 * math.log((1 + value) / (1 - value)) + 0.5 * nz(fish[1])
    fish

//-----------------------------------------------------------------------------
// AHRENS MOVING AVERAGE
//-----------------------------------------------------------------------------
//@function Calculates Ahrens Moving Average
//@param src Source series
//@param len Period length
//@returns Ahrens MA value
export ahrensMA(float src, int len) =>
    var float ahrens = na
    ahrens := na(ahrens[1]) ? src : ahrens[1] + (src - ahrens[1]) / len
    ahrens

//-----------------------------------------------------------------------------
// MOVING AVERAGE SELECTOR (COMPLETE)
//-----------------------------------------------------------------------------
//@function Master function to select and calculate any moving average type
//@param src Source series
//@param len Period length
//@param maType Type of MA - supports 50+ types
//@returns Selected MA value
export selector(float src, int len, string maType) =>
    float result = switch maType
        // Basic Moving Averages
        "SMA" => ta.sma(src, len)
        "EMA" => ta.ema(src, len)
        "WMA" => ta.wma(src, len)
        "VWMA" => ta.vwma(src, len)
        "RMA" => ta.rma(src, len)
        "SMMA" => smma(src, len)
        "SWMA" => swma(src)
        // Hull Family
        "HMA" => ta.hma(src, len)
        "EHMA" => ehma(src, len)
        // Double/Triple Smoothed
        "DEMA" => dema(src, len)
        "TEMA" => tema(src, len)
        "TMA" => tma(src, len)
        "T3" => t3(src, len)
        "TWMA" => twma(src, len)
        "SWWMA" => swwma(src, len)
        "TRIXSMOOTH" => trixSmooth(src, len)
        // Zero/Low Lag
        "ZLEMA" => zlema(src, len)
        "LSMA" => lsma(src, len)
        "EPMA" => epma(src, len)
        "ILRS" => ilrs(src, len)
        // Adaptive Moving Averages
        "KAMA" => kama(src, len)
        "FRAMA" => frama(src, len)
        "VIDYA" => vidya(src, len)
        "VMA" => vma(src, len)
        "VAMA" => vama(src, len)
        "RVMA" => rvma(src, len)
        "APEXMA" => apexMA(src, len)
        // Ehlers Filters
        "SUPERSMOOTHER" => superSmoother(src, len)
        "BUTTERWORTH2" => butterworth2(src, len)
        "BUTTERWORTH3" => butterworth3(src, len)
        "INSTANTTREND" => instantTrend(src)
        "EDSMA" => edsma(src, len)
        // Laguerre Family
        "LAGUERRE" => laguerreFilter(src, 0.8)
        "ADAPTIVELAGUERRE" => adaptiveLaguerre(src, len)
        // Special Weighted
        "ALMA" => ta.alma(src, len, 0.85, 6)
        "SINWMA" => sinwma(src, len)
        "GWMA" => gwma(src, len)
        "NMA" => nma(src, len)
        // Jurik/McGinley/Coral
        "JMA" => jma(src, len)
        "MCGINLEY" => mcginley(src, len)
        "CORAL" => coral(src, len)
        // Mean Types
        "MEDIANMA" => medianMA(src, len)
        "GMA" => gma(src, len)
        "HARMONICMA" => harmonicMA(src, len)
        "TRIMMEDMA" => trimmedMA(src, len)
        // Volume-Based
        "EVWMA" => evwma(src, len)
        // Other Specialized
        "HWMA" => hwma(src, len)
        "GDEMA" => gdema(src, len)
        "REMA" => rema(src, len)
        "MODULARFILTER" => modularFilter(src, len)
        "RMT" => rmt(src, len)
        "QRMA" => qrma(src, len)
        "WILDERSMOOTH" => wilderSmooth(src, len)
        "LEOMA" => leoMA(src, len)
        "AHRENSMA" => ahrensMA(src, len)
        "RUNNINGMA" => runningMA(src, len)
        "PPOMA" => ppoMA(src, len)
        "MAMA" => mama(src)
        "FAMAVAL" => fama(src)
        "FISHERMA" => fisherMA(src, len)
        "CMA" => cma(src)
        => ta.sma(src, len)
    result

//-----------------------------------------------------------------------------
// GET ALL MA TYPES (Helper for input options)
//-----------------------------------------------------------------------------
//@function Returns array of all supported MA type names for input.string options
//@returns String of all MA types
export getAllTypes() =>
    "SMA,EMA,WMA,VWMA,RMA,SMMA,SWMA,HMA,EHMA,DEMA,TEMA,TMA,T3,TWMA,SWWMA,TRIXSMOOTH,ZLEMA,LSMA,EPMA,ILRS,KAMA,FRAMA,VIDYA,VMA,VAMA,RVMA,APEXMA,SUPERSMOOTHER,BUTTERWORTH2,BUTTERWORTH3,INSTANTTREND,EDSMA,LAGUERRE,ADAPTIVELAGUERRE,ALMA,SINWMA,GWMA,NMA,JMA,MCGINLEY,CORAL,MEDIANMA,GMA,HARMONICMA,TRIMMEDMA,EVWMA,HWMA,GDEMA,REMA,MODULARFILTER,RMT,QRMA,WILDERSMOOTH,LEOMA,AHRENSMA,RUNNINGMA,PPOMA,MAMA,FAMAVAL,FISHERMA,CMA"